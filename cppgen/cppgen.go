package cppgen

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/gamewheels/cfgwheel/cfgdef"
)

// CPPGen C++胶水代码生成器
type CPPGen struct {
	cfgMap *cfgdef.CfgMap
}

// NewCPPGen 构建C++胶水代码生成器
func NewCPPGen(cfgMap *cfgdef.CfgMap) *CPPGen {
	return &CPPGen{
		cfgMap: cfgMap,
	}
}

func genStructName(name string) string {
	if strings.HasSuffix(name, "Table") {
		return name[:len(name)-5] + "Struct"
	} else if strings.HasSuffix(name, "Settings") {
		return name + "Struct"
	}
	return name
}

func getTypeName(field *cfgdef.FieldDef) string {
	if field.IsEnum || field.IsStruct {
		return field.Type
	}
	switch field.Type {
	case "float32":
		return "float"
	case "float64":
		return "double"
	case "string":
		return "std::string"
	case "byte":
		return "int8_t"
	case "bool":
		return field.Type
	}
	return field.Type + "_t"
}

// GenType 生成类型名称
func genType(typeName string, isArray bool) string {
	if isArray {
		return "std::vector<" + typeName + ">"
	}
	return typeName
}

// GenFileName 生成文件名
func (gen *CPPGen) GenFileName(name string) string {
	return name + ".h"
}

// GenEnum 生成枚举
func (gen *CPPGen) GenEnum(name string) string {
	enumDef := gen.cfgMap.EnumMap[name]
	if enumDef == nil || len(enumDef.Items) == 0 {
		fmt.Println("error: ", name, "定义无效")
		return ""
	}
	var buff bytes.Buffer
	buff.WriteString("//Code generated by game config export tool. DO NOT EDIT.")
	buff.WriteString("\n\n//" + name + " " + enumDef.Desc)
	buff.WriteString("\nenum " + name)
	buff.WriteString("\n{")
	name2 := name[:len(name)-4]
	for i := 0; i < len(enumDef.Items); i++ {
		item := enumDef.Items[i]
		buff.WriteString("\n\t//" + name2 + item.Name + " " + item.Desc)
		buff.WriteString("\n\t" + name2 + item.Name + " = " + item.Value + ",")
	}
	buff.WriteString("\n};\n")
	return buff.String()
}

// GenTable 生成表
func (gen *CPPGen) GenTable(name string) string {
	tableDef := gen.cfgMap.TableMap[name]
	if tableDef == nil || len(tableDef.Fields) == 0 {
		fmt.Println("error: ", name, "定义无效")
		return ""
	}

	structName := genStructName(name)
	isTable := strings.HasSuffix(name, "Table")
	isSettings := strings.HasSuffix(name, "Settings")

	var buff bytes.Buffer
	var buff2 bytes.Buffer
	var buff3 bytes.Buffer
	var buff4 bytes.Buffer

	buff.WriteString("//Code generated by game config export tool. DO NOT EDIT.")
	buff.WriteString("\n#pragma once")
	buff.WriteString("\n#include <Singleton.h>")
	buff.WriteString("\n#include <TableBase.h>")
	buff.WriteString("\n")
	if isSettings {
		buff.WriteString("\n#define " + name + " Singleton<" + structName + ">::GetInstance()")
	} else if isTable {
		buff2.WriteString("\nclass " + structName + ";")
		buff2.WriteString("\ntypedef const " + structName + " *" + structName + "Ptr;")
		buff2.WriteString("\n#define " + name + " TableBase<" + structName + ">::GetInstance()")
	}

	buff2.WriteString("\n\n//" + structName + " " + tableDef.Desc)
	buff2.WriteString("\nstruct " + structName)
	buff2.WriteString("\n{")

	for i := 0; i < len(tableDef.Fields); i++ {
		field := tableDef.Fields[i]
		if field.Name != "" && field.Type != "" &&
			(field.IsKey || field.UseFor == "A" || field.UseFor == cfgdef.ExportFlags.UseFor) {
			typeName := getTypeName(field)
			if field.IsStruct {
				buff.WriteString("\nstruct " + typeName + ";")
			} else if field.IsEnum {
				buff.WriteString("\nenum " + typeName + ";")
			}
			buff2.WriteString("\n\t//" + field.Name + " " + field.Desc)
			buff2.WriteString("\n\t" + genType(typeName, field.IsArray) + " " + field.Name + ";")
			if field.IsArray {
				if strings.HasSuffix(typeName, "Struct") {
					buff3.WriteString("\n\t\tPARSE_STRUCT_ARRAY(" + field.Name + ");")
				} else {
					buff3.WriteString("\n\t\tPARSE_ARRAY(" + field.Name + ", " + typeName + ");")
				}
			} else {
				if strings.HasSuffix(typeName, "Struct") {
					buff3.WriteString("\n\t\tPARSE_STRUCT(" + field.Name + ");")
				} else {
					buff3.WriteString("\n\t\tPARSE_FIELD(" + field.Name + ");")
				}
			}
			if field.FTable != "" {
				relateName := field.Name + "2" + field.FTable
				buff2.WriteString("\n\t//" + relateName + " " + field.Name + " --> " + field.FTable)
				buff2.WriteString("\n\t" + genType(field.FTable+"Struct *", field.IsArray) + " " + relateName + ";")
				if field.IsArray {
					buff4.WriteString("\n\t\tRELATE_ARRAY(" + field.Name + ", " + field.FTable + ");")
				} else {
					buff4.WriteString("\n\t\tRELATE_FIELD(" + field.Name + ", " + field.FTable + ");")
				}
			}
		}
	}
	if isTable {
		keyField := tableDef.Fields[tableDef.Key]
		buff2.WriteString("\n\n\ttypedef " + getTypeName(keyField) + " KEY_TYPE;")
		buff2.WriteString("\n\tKEY_TYPE GetKey() { return this->ID; }")
	}
	buff2.WriteString("\n\n\tvoid Parse(const JSONValue &v)")
	buff2.WriteString("\n\t{")
	buff2.WriteString(buff3.String())
	buff2.WriteString("\n\t}")

	buff2.WriteString("\n\n\tvoid Relate()")
	buff2.WriteString("\n\t{")
	buff2.WriteString(buff4.String())
	buff2.WriteString("\n\t}")

	buff.WriteString(buff2.String())
	buff.WriteString("\n};\n")
	return buff.String()
}
