package gogen

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/gamewheels/cfgwheel/cfgdef"
)

// 生成包名
var packageName = "gameconfig"

// GoGen golang胶水代码生成器
type GoGen struct {
	cfgMap *cfgdef.CfgMap
}

// NewGoGen 构建golang胶水代码生成器
func NewGoGen(cfgMap *cfgdef.CfgMap) *GoGen {
	return &GoGen{
		cfgMap: cfgMap,
	}
}

func genStructName(name string) string {
	if strings.HasSuffix(name, "Table") {
		return name[:len(name)-5] + "Struct"
	} else if strings.HasSuffix(name, "Settings") {
		return name + "Struct"
	}
	return name
}

// GenType 生成类型名称
func genType(typeName string, isArray bool) string {
	return cfgdef.GetArraySymbol(isArray) + typeName
}

// GenFileName 生成文件名
func (gen *GoGen) GenFileName(name string) string {
	return name + ".go"
}

// GenEnum 生成枚举
func (gen *GoGen) GenEnum(name string) string {
	enumDef := gen.cfgMap.EnumMap[name]
	if enumDef == nil || len(enumDef.Items) == 0 {
		fmt.Println("error: ", name, "定义无效")
		return ""
	}
	var buff bytes.Buffer
	buff.WriteString("// Code generated by game config export tool. DO NOT EDIT.")
	buff.WriteString("\npackage " + packageName)
	buff.WriteString("\n\n// " + name + " " + enumDef.Desc)
	buff.WriteString("\ntype " + name + " int")
	buff.WriteString("\n\nconst (")
	name2 := name[:len(name)-4]
	for i := 0; i < len(enumDef.Items); i++ {
		item := enumDef.Items[i]
		buff.WriteString("\n\t// " + name2 + item.Name + " " + item.Desc)
		buff.WriteString("\n\t" + name2 + item.Name + " " + name + " = " + item.Value)
	}
	buff.WriteString("\n)")
	return buff.String()
}

// GenTable 生成表
func (gen *GoGen) GenTable(name string) string {
	tableDef := gen.cfgMap.TableMap[name]
	if tableDef == nil || len(tableDef.Fields) == 0 {
		fmt.Println("error: ", name, "定义无效")
		return ""
	}

	structName := genStructName(name)
	isTable := strings.HasSuffix(name, "Table")
	isSettings := strings.HasSuffix(name, "Settings")

	var buff bytes.Buffer
	var buff2 bytes.Buffer

	buff.WriteString("// Code generated by game config export tool. DO NOT EDIT.")
	buff.WriteString("\npackage " + packageName)
	buff.WriteString("\n\nimport (")
	buff.WriteString("\n\t\"encoding/json\"")
	buff.WriteString("\n\t\"log\"")
	buff.WriteString("\n)")
	buff.WriteString("\n\n// " + structName + " " + tableDef.Desc)
	buff.WriteString("\ntype " + structName + " struct {")
	for i := 0; i < len(tableDef.Fields); i++ {
		field := tableDef.Fields[i]
		if field.Name != "" && field.Type != "" &&
			(field.IsKey || field.UseFor == "A" || field.UseFor == cfgdef.ExportFlags.UseFor) {
			buff.WriteString("\n\t// " + field.Name + " " + field.Desc)
			buff.WriteString("\n\t" + field.Name + " " + genType(field.Type, field.IsArray))
			if field.FTable != "" {
				relateName := field.Name + "2" + field.FTable
				buff.WriteString("\n\t// " + relateName + " " + field.Name + "关联的" + field.FTable)
				buff.WriteString("\n\t" + relateName + " " + cfgdef.GetArraySymbol(field.IsArray) + "*" + field.FTable + "Struct `json:\"-\"`")
				if field.IsArray {
					buff2.WriteString("\n\tr." + relateName + " = make([]*" + field.FTable + "Struct, len(r." + field.Name + "))")
					buff2.WriteString("\n\tfor i := 0; i < len(r." + field.Name + "); i++ {")
					buff2.WriteString("\n\t\tr." + relateName + "[i], ok = " + field.FTable + "Table[r." + field.Name + "[i]]")
					buff2.WriteString("\n\t\tif !ok {")
					buff2.WriteString("\n\t\t\tlog.Println(\"error: can't find " + field.FTable + ":\", r." + field.Name + "[i])")
					buff2.WriteString("\n\t\t}")
					buff2.WriteString("\n\t}")
				} else {
					buff2.WriteString("\n\tr." + relateName + ", ok = " + field.FTable + "Table[r." + field.Name + "]")
					buff2.WriteString("\n\tif !ok {")
					buff2.WriteString("\n\t\tlog.Println(\"error: can't find " + field.FTable + ":\", r." + field.Name + ")")
					buff2.WriteString("\n\t}")
				}
			}
		}
	}
	buff.WriteString("\n}")
	if isTable {
		keyField := tableDef.Fields[tableDef.Key]
		buff.WriteString("\n\n// " + name + " " + tableDef.Desc)
		buff.WriteString("\nvar " + name + " = make(map[" + keyField.Type + "]*" + structName + ")")
	} else if isSettings {
		buff.WriteString("\n\n// " + name + " " + tableDef.Desc)
		buff.WriteString("\nvar " + name + " " + structName)
	}

	buff.WriteString("\n\n// Unmarshal Unmarshal")
	buff.WriteString("\nfunc (r " + structName + ") Unmarshal(s []byte) error {")
	buff.WriteString("\n\terr := json.Unmarshal(s, &r)")
	buff.WriteString("\n\tif err != nil {")
	buff.WriteString("\n\t\tlog.Println(\"error:\", err)")
	buff.WriteString("\n\t}")
	buff.WriteString("\n\treturn err")
	buff.WriteString("\n}")

	if buff2.Len() > 0 {
		buff.WriteString("\n\n// Relate 父子表关联")
		buff.WriteString("\nfunc (r *" + structName + ") Relate() {")
		buff.WriteString("\n\tvar ok bool")
		buff.WriteString(buff2.String())
		buff.WriteString("\n}")
	}

	if isTable {
		keyField := tableDef.Fields[tableDef.Key]
		buff.WriteString("\n\n// " + name + "Load 数据加载")
		buff.WriteString("\nfunc " + name + "Load(s []byte) {")
		buff.WriteString("\n\tvar data []*" + structName)
		buff.WriteString("\n\terr := json.Unmarshal(s, &data)")
		buff.WriteString("\n\tif err != nil {")
		buff.WriteString("\n\t\tlog.Println(\"error:\", err)")
		buff.WriteString("\n\t\treturn")
		buff.WriteString("\n\t}")
		buff.WriteString("\n\tfor _, row := range data {")
		buff.WriteString("\n\t\t_, ok := " + name + "[row." + keyField.Name + "]")
		buff.WriteString("\n\t\tif ok {")
		buff.WriteString("\n\t\t\tlog.Println(\"" + name + " replace:\", row)")
		buff.WriteString("\n\t\t}")
		buff.WriteString("\n\t\t" + name + "[row." + keyField.Name + "] = row")
		buff.WriteString("\n\t}")
		buff.WriteString("\n}")

		buff.WriteString("\n\n// " + name + "Relate 父子表关联")
		buff.WriteString("\nfunc " + name + "Relate() {")
		if buff2.Len() > 0 {
			buff.WriteString("\n\tfor _, r := range " + name + " {")
			buff.WriteString("\n\t\tr.Relate()")
			buff.WriteString("\n\t}")
		}
		buff.WriteString("\n}")
	} else if isSettings {
		buff.WriteString("\n\n// " + name + "Load 数据加载")
		buff.WriteString("\nfunc " + name + "Load(s []byte) {")
		buff.WriteString("\n\terr := json.Unmarshal(s, &" + name + ")")
		buff.WriteString("\n\tif err != nil {")
		buff.WriteString("\n\t\tlog.Println(\"error:\", err)")
		buff.WriteString("\n\t}")
		buff.WriteString("\n}")
	}
	buff.WriteString("\n")
	return buff.String()
}
